Proc :: (param : Any)
{
	if param.typeInfo.typeKind == TypeKind_Integer
	{
		intInfo := cast(^TypeInfoInteger) param.typeInfo;
		num : s64;
		if intInfo.size == 1
			num = @ cast(^s8) param.data;
		else if intInfo.size == 2
			num = @ cast(^s16) param.data;
		else if intInfo.size == 4
			num = @ cast(^s32) param.data;
		else if intInfo.size == 8
			num = @ cast(^s64) param.data;

		buffer : [16] u8;
		n := num;
		count := 0;
		while n > 0
		{
			digit := n % 10;
			buffer[15 - count] = cast(u8) digit + 48;
			count += 1;
			n /= 10;
		}
		numStr : String;
		numStr.size = cast(u64) count;
		numStr.data = ^buffer[16 - count];
		Print(numStr);
	}
	else if param.typeInfo.typeKind == TypeKind_Floating
	{
		floatInfo := cast(^TypeInfoFloating) param.typeInfo;
		f : f64;
		if floatInfo.size == 4
			f = @ cast(^f32) param.data;
		else if floatInfo.size == 8
			f = @ cast(^f64) param.data;

		// Cheat
		buffer : [32] u8;
		count := 0;

		// Fraction
		n : s64 = f * 10000000;
		i := 7;
		while i > 0
		{
			digit := n % 10;
			buffer[31 - count] = cast(u8) digit + 48;
			count += 1;
			n /= 10;
			i -= 1;
		}
		buffer[31 - count] = 46;
		count += 1;

		// Wholes
		n = f;
		while n > 0
		{
			digit := n % 10;
			buffer[31 - count] = cast(u8) digit + 48;
			count += 1;
			n /= 10;
		}
		numStr : String;
		numStr.size = cast(u64) count;
		numStr.data = ^buffer[32 - count];
		Print(numStr);
	}
	Print("\n");
}

Main :: () -> s64
{
	n : s64 = 2345;
	a : Any;
	a.typeInfo = typeof(n);
	a.data = ^n;
	Proc(a);

	anAny : Any = n;

	Proc(12345.6789);

	return 0;
}

__ImageBase : #external ^void;

// Size-based types
BYTE  :: #alias u8;
WORD  :: #alias u16;
DWORD :: #alias u32;
QWORD :: #alias u64;

// Fluffy C-like types
BOOL      :: #alias s32;
CHAR      :: #alias s8;
SHORT     :: #alias s16;
USHORT    :: #alias u16;
INT       :: #alias s32;
UINT      :: #alias u32;
LONG      :: #alias s32;
ULONG     :: #alias u32;
LONGLONG  :: #alias s64;
ULONGLONG :: #alias u64;
FLOAT     :: #alias f32;

// Weird size-based types
UINT8     :: #alias u8;
WCHAR     :: #alias s16;
DWORD32   :: #alias u32;
DWORD64   :: #alias u64;
LONG32    :: #alias s32;
LONG64    :: #alias s64;
ULONG32   :: #alias u32;
ULONG64   :: #alias u64;
DWORDLONG :: #alias u64;
SIZE_T    :: #alias u64;

// Other weird windows types
HANDLE  :: #alias ^void;
LPARAM  :: #alias u64;
WPARAM  :: #alias u64;
LRESULT :: #alias u64;
HRESULT :: #alias s32;

// Function types
THREAD_START_ROUTINE :: #alias #convention(win64) (lpThreadParameter: ^void) -> DWORD;

// Constants and flags
INFINITE :: 0xFFFFFFFF;
INVALID_HANDLE_VALUE :: 0xFFFFFFFFFFFFFFFF;
ERROR_SUCCESS :: 0;
MEM_COMMIT      :: 0x00001000;
MEM_RESERVE     :: 0x00002000;
MEM_RESET       :: 0x00080000;
MEM_TOP_DOWN    :: 0x00100000;
MEM_WRTIE_WATCH :: 0x00200000;
MEM_PHYSICAL    :: 0x00400000;
MEM_RESET_UNDO  :: 0x01000000;
MEM_LARGE_PAGES :: 0x20000000;
MEM_DECOMMIT    :: 0x00004000;
MEM_RELEASE     :: 0x00008000;
PAGE_NOACCESS          :: 0x01;
PAGE_READONLY          :: 0x02;
PAGE_READWRITE         :: 0x04;
PAGE_WRITECOPY         :: 0x08;
PAGE_EXECUTE           :: 0x10;
PAGE_EXECUTE_READ      :: 0x20;
PAGE_EXECUTE_READWRITE :: 0x40;
PAGE_EXECUTE_WRITECOPY :: 0x80;
PAGE_GUARD             :: 0x100;
PAGE_NOCACHE           :: 0x200;
PAGE_WRITECOMBINE      :: 0x400;
PAGE_TARGETS_INVALID   :: 0x40000000;
PAGE_TARGETS_NO_UPDATE :: 0x40000000;
GENERIC_READ    :: 0x80000000;
GENERIC_WRITE   :: 0x40000000;
GENERIC_EXECUTE :: 0x20000000;
GENERIC_ALL     :: 0x10000000;
CREATE_NEW        :: 1;
CREATE_ALWAYS     :: 2;
OPEN_EXISTING     :: 3;
OPEN_ALWAYS       :: 4;
TRUNCATE_EXISTING :: 5;
FILE_SHARE_READ   :: 1;
FILE_SHARE_WRITE  :: 2;
FILE_SHARE_DELETE :: 4;
FILE_ATTRIBUTE_READONLY  :: 0x1;
FILE_ATTRIBUTE_HIDDEN    :: 0x2;
FILE_ATTRIBUTE_SYSTEM    :: 0x4;
FILE_ATTRIBUTE_ARCHIVE   :: 0x20;
FILE_ATTRIBUTE_NORMAL    :: 0x80;
FILE_ATTRIBUTE_TEMPORARY :: 0x100;
FILE_ATTRIBUTE_OFFLINE   :: 0x1000;
FILE_ATTRIBUTE_ENCRYPTED :: 0x4000;
ATTACH_PARENT_PROCESS :: -1;
WS_TILED            :: 0x00000000;
WS_OVERLAPPED       :: 0x00000000;
WS_MAXIMIZEBOX      :: 0x00010000;
WS_TABSTOP          :: 0x00010000;
WS_GROUP            :: 0x00020000;
WS_MINIMIZEBOX      :: 0x00020000;
WS_THICKFRAME       :: 0x00040000;
WS_SIZEBOX          :: 0x00040000;
WS_SYSMENU          :: 0x00080000;
WS_HSCROLL          :: 0x00100000;
WS_VSCROLL          :: 0x00200000;
WS_DLGFRAME         :: 0x00400000;
WS_BORDER           :: 0x00800000;
WS_CAPTION          :: 0x00C00000;
WS_MAXIMIZE         :: 0x01000000;
WS_CLIPCHILDREN     :: 0x02000000;
WS_CLIPSIBLINGS     :: 0x04000000;
WS_DISABLED         :: 0x08000000;
WS_VISIBLE          :: 0x10000000;
WS_ICONIC           :: 0x20000000;
WS_MINIMIZE         :: 0x20000000;
WS_CHILD            :: 0x40000000;
WS_CHILDWINDOW      :: 0x40000000;
WS_POPUP            :: 0x80000000;
WS_OVERLAPPEDWINDOW :: WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
CS_VREDRAW :: 0x0001;
CS_HREDRAW :: 0x0002;
CS_OWNDC   :: 0x0020;
SW_HIDE            :: 0;
SW_SHOWNORMAL      :: 1;
SW_NORMAL          :: 1;
SW_SHOWMINIMIZED   :: 2;
SW_SHOWMAXIMIZED   :: 3;
SW_MAXIMIZE        :: 3;
SW_SHOWNOACTIVATE  :: 4;
SW_SHOW            :: 5;
SW_MINIMIZE        :: 6;
SW_SHOWMINNOACTIVE :: 7;
SW_SHOWNA          :: 8;
SW_RESTORE         :: 9;
SW_SHOWDEFAULT     :: 10;
SW_FORCEMINIMIZE   :: 11;
PM_REMOVE  :: 0x0001;
WM_DESTROY :: 0x0002;
WM_SIZE    :: 0x0005;
WM_CLOSE   :: 0x0010;
WM_QUIT    :: 0x0012;
WM_KEYDOWN :: 0x0100;
WM_KEYUP   :: 0x0101;
PFD_DOUBLEBUFFER   :: 0x00000001;
PFD_DRAW_TO_WINDOW :: 0x00000004;
PFD_SUPPORT_OPENGL :: 0x00000020;
PFD_TYPE_RGBA :: 0;
STD_INPUT_HANDLE :: -10;
STD_OUTPUT_HANDLE :: -11;
STD_ERROR_HANDLE :: -12;
CONTEXT_AMD64			:: 0x00100000;
CONTEXT_CONTROL			:: CONTEXT_AMD64 | 0x00000001;
CONTEXT_INTEGER			:: CONTEXT_AMD64 | 0x00000002;
CONTEXT_SEGMENTS		:: CONTEXT_AMD64 | 0x00000004;
CONTEXT_FLOATING_POINT	:: CONTEXT_AMD64 | 0x00000008;
CONTEXT_DEBUG_REGISTERS	:: CONTEXT_AMD64 | 0x00000010;
CONTEXT_FULL			:: CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;
CONTEXT_ALL				:: CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS |
						   CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS;
CONTEXT_XSTATE			:: CONTEXT_AMD64 | 0x00000040;
KEY_EVENT :: 0x0001;
MOUSE_EVENT :: 0x0002;
WINDOW_BUFFER_SIZE_EVENT :: 0x0004;
MENU_EVENT :: 0x0008;
FOCUS_EVENT :: 0x0010;

// Process creation flags
DEBUG_PROCESS                    :: 0x00000001;
DEBUG_ONLY_THIS_PROCESS          :: 0x00000002;
CREATE_SUSPENDED                 :: 0x00000004;
DETACHED_PROCESS                 :: 0x00000008;
CREATE_NEW_CONSOLE               :: 0x00000010;
CREATE_NEW_PROCESS_GROUP         :: 0x00000200;
CREATE_UNICODE_ENVIRONMENT       :: 0x00000400;
CREATE_SEPARATE_WOW_VDM          :: 0x00000800;
CREATE_SHARED_WOW_VDM            :: 0x00001000;
EXTENDED_STARTUPINFO_PRESENT     :: 0x00080000;
INHERIT_PARENT_AFFINITY          :: 0x00010000;
CREATE_PROTECTED_PROCESS         :: 0x00040000;
CREATE_SECURE_PROCESS            :: 0x00400000;
CREATE_BREAKAWAY_FROM_JOB        :: 0x01000000;
CREATE_PRESERVE_CODE_AUTHZ_LEVEL :: 0x02000000;
CREATE_DEFAULT_ERROR_MODE        :: 0x04000000;
CREATE_NO_WINDOW                 :: 0x08000000;

// Virtual Keys, Standard Set
VK_LBUTTON :: 0x01;
VK_RBUTTON :: 0x02;
VK_CANCEL :: 0x03;
VK_MBUTTON :: 0x04;    /* NOT contiguous with L & RBUTTON */
VK_XBUTTON1 :: 0x05;    /* NOT contiguous with L & RBUTTON */
VK_XBUTTON2 :: 0x06;    /* NOT contiguous with L & RBUTTON */
VK_BACK :: 0x08;
VK_TAB :: 0x09;
VK_CLEAR :: 0x0C;
VK_RETURN :: 0x0D;
VK_SHIFT :: 0x10;
VK_CONTROL :: 0x11;
VK_MENU :: 0x12;
VK_PAUSE :: 0x13;
VK_CAPITAL :: 0x14;
VK_KANA :: 0x15;
VK_HANGEUL :: 0x15;  /* old name - should be here for compatibility */
VK_HANGUL :: 0x15;
VK_JUNJA :: 0x17;
VK_FINAL :: 0x18;
VK_HANJA :: 0x19;
VK_KANJI :: 0x19;
VK_ESCAPE :: 0x1B;
VK_CONVERT :: 0x1C;
VK_NONCONVERT :: 0x1D;
VK_ACCEPT :: 0x1E;
VK_MODECHANGE :: 0x1F;
VK_SPACE :: 0x20;
VK_PRIOR :: 0x21;
VK_NEXT :: 0x22;
VK_END :: 0x23;
VK_HOME :: 0x24;
VK_LEFT :: 0x25;
VK_UP :: 0x26;
VK_RIGHT :: 0x27;
VK_DOWN :: 0x28;
VK_SELECT :: 0x29;
VK_PRINT :: 0x2A;
VK_EXECUTE :: 0x2B;
VK_SNAPSHOT :: 0x2C;
VK_INSERT :: 0x2D;
VK_DELETE :: 0x2E;
VK_HELP :: 0x2F;
VK_LWIN :: 0x5B;
VK_RWIN :: 0x5C;
VK_APPS :: 0x5D;
VK_SLEEP :: 0x5F;
VK_NUMPAD0 :: 0x60;
VK_NUMPAD1 :: 0x61;
VK_NUMPAD2 :: 0x62;
VK_NUMPAD3 :: 0x63;
VK_NUMPAD4 :: 0x64;
VK_NUMPAD5 :: 0x65;
VK_NUMPAD6 :: 0x66;
VK_NUMPAD7 :: 0x67;
VK_NUMPAD8 :: 0x68;
VK_NUMPAD9 :: 0x69;
VK_MULTIPLY :: 0x6A;
VK_ADD :: 0x6B;
VK_SEPARATOR :: 0x6C;
VK_SUBTRACT :: 0x6D;
VK_DECIMAL :: 0x6E;
VK_DIVIDE :: 0x6F;
VK_F1 :: 0x70;
VK_F2 :: 0x71;
VK_F3 :: 0x72;
VK_F4 :: 0x73;
VK_F5 :: 0x74;
VK_F6 :: 0x75;
VK_F7 :: 0x76;
VK_F8 :: 0x77;
VK_F9 :: 0x78;
VK_F10 :: 0x79;
VK_F11 :: 0x7A;
VK_F12 :: 0x7B;
VK_F13 :: 0x7C;
VK_F14 :: 0x7D;
VK_F15 :: 0x7E;
VK_F16 :: 0x7F;
VK_F17 :: 0x80;
VK_F18 :: 0x81;
VK_F19 :: 0x82;
VK_F20 :: 0x83;
VK_F21 :: 0x84;
VK_F22 :: 0x85;
VK_F23 :: 0x86;
VK_F24 :: 0x87;
VK_NAVIGATION_VIEW :: 0x88; // reserved
VK_NAVIGATION_MENU :: 0x89; // reserved
VK_NAVIGATION_UP :: 0x8A; // reserved
VK_NAVIGATION_DOWN :: 0x8B; // reserved
VK_NAVIGATION_LEFT :: 0x8C; // reserved
VK_NAVIGATION_RIGHT :: 0x8D; // reserved
VK_NAVIGATION_ACCEPT :: 0x8E; // reserved
VK_NAVIGATION_CANCEL :: 0x8F; // reserved
VK_NUMLOCK :: 0x90;
VK_SCROLL :: 0x91;
VK_OEM_NEC_EQUAL :: 0x92; // '=' key on numpad
VK_OEM_FJ_JISHO :: 0x92; // 'Dictionary' key
VK_OEM_FJ_MASSHOU :: 0x93; // 'Unregister word' key
VK_OEM_FJ_TOUROKU :: 0x94; // 'Register word' key
VK_OEM_FJ_LOYA :: 0x95; // 'Left OYAYUBI' key
VK_OEM_FJ_ROYA :: 0x96; // 'Right OYAYUBI' key
VK_LSHIFT :: 0xA0;
VK_RSHIFT :: 0xA1;
VK_LCONTROL :: 0xA2;
VK_RCONTROL :: 0xA3;
VK_LMENU :: 0xA4;
VK_RMENU :: 0xA5;
VK_BROWSER_BACK :: 0xA6;
VK_BROWSER_FORWARD :: 0xA7;
VK_BROWSER_REFRESH :: 0xA8;
VK_BROWSER_STOP :: 0xA9;
VK_BROWSER_SEARCH :: 0xAA;
VK_BROWSER_FAVORITES :: 0xAB;
VK_BROWSER_HOME :: 0xAC;
VK_VOLUME_MUTE :: 0xAD;
VK_VOLUME_DOWN :: 0xAE;
VK_VOLUME_UP :: 0xAF;
VK_MEDIA_NEXT_TRACK :: 0xB0;
VK_MEDIA_PREV_TRACK :: 0xB1;
VK_MEDIA_STOP :: 0xB2;
VK_MEDIA_PLAY_PAUSE :: 0xB3;
VK_LAUNCH_MAIL :: 0xB4;
VK_LAUNCH_MEDIA_SELECT :: 0xB5;
VK_LAUNCH_APP1 :: 0xB6;
VK_LAUNCH_APP2 :: 0xB7;
VK_OEM_1 :: 0xBA; // ';:' for US
VK_OEM_PLUS :: 0xBB; // '+' any country
VK_OEM_COMMA :: 0xBC; // ',' any country
VK_OEM_MINUS :: 0xBD; // '-' any country
VK_OEM_PERIOD :: 0xBE; // '.' any country
VK_OEM_2 :: 0xBF; // '/?' for US
VK_OEM_3 :: 0xC0; // '`~' for US
VK_GAMEPAD_A :: 0xC3; // reserved
VK_GAMEPAD_B :: 0xC4; // reserved
VK_GAMEPAD_X :: 0xC5; // reserved
VK_GAMEPAD_Y :: 0xC6; // reserved
VK_GAMEPAD_RIGHT_SHOULDER :: 0xC7; // reserved
VK_GAMEPAD_LEFT_SHOULDER :: 0xC8; // reserved
VK_GAMEPAD_LEFT_TRIGGER :: 0xC9; // reserved
VK_GAMEPAD_RIGHT_TRIGGER :: 0xCA; // reserved
VK_GAMEPAD_DPAD_UP :: 0xCB; // reserved
VK_GAMEPAD_DPAD_DOWN :: 0xCC; // reserved
VK_GAMEPAD_DPAD_LEFT :: 0xCD; // reserved
VK_GAMEPAD_DPAD_RIGHT :: 0xCE; // reserved
VK_GAMEPAD_MENU :: 0xCF; // reserved
VK_GAMEPAD_VIEW :: 0xD0; // reserved
VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON :: 0xD1; // reserved
VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON :: 0xD2; // reserved
VK_GAMEPAD_LEFT_THUMBSTICK_UP :: 0xD3; // reserved
VK_GAMEPAD_LEFT_THUMBSTICK_DOWN :: 0xD4; // reserved
VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT :: 0xD5; // reserved
VK_GAMEPAD_LEFT_THUMBSTICK_LEFT :: 0xD6; // reserved
VK_GAMEPAD_RIGHT_THUMBSTICK_UP :: 0xD7; // reserved
VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN :: 0xD8; // reserved
VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT :: 0xD9; // reserved
VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT :: 0xDA; // reserved
VK_OEM_4 :: 0xDB; //  '[{' for US
VK_OEM_5 :: 0xDC; //  '\|' for US
VK_OEM_6 :: 0xDD; //  ']}' for US
VK_OEM_7 :: 0xDE; //  ''"' for US
VK_OEM_8 :: 0xDF;
VK_OEM_AX :: 0xE1; //  'AX' key on Japanese AX kbd
VK_OEM_102 :: 0xE2; //  "<>" or "\|" on RT 102-key kbd.
VK_ICO_HELP :: 0xE3; //  Help key on ICO
VK_ICO_00 :: 0xE4; //  00 key on ICO
VK_PROCESSKEY :: 0xE5;
VK_ICO_CLEAR :: 0xE6;
VK_PACKET :: 0xE7;
VK_OEM_RESET :: 0xE9;
VK_OEM_JUMP :: 0xEA;
VK_OEM_PA1 :: 0xEB;
VK_OEM_PA2 :: 0xEC;
VK_OEM_PA3 :: 0xED;
VK_OEM_WSCTRL :: 0xEE;
VK_OEM_CUSEL :: 0xEF;
VK_OEM_ATTN :: 0xF0;
VK_OEM_FINISH :: 0xF1;
VK_OEM_COPY :: 0xF2;
VK_OEM_AUTO :: 0xF3;
VK_OEM_ENLW :: 0xF4;
VK_OEM_BACKTAB :: 0xF5;
VK_ATTN :: 0xF6;
VK_CRSEL :: 0xF7;
VK_EXSEL :: 0xF8;
VK_EREOF :: 0xF9;
VK_PLAY :: 0xFA;
VK_ZOOM :: 0xFB;
VK_NONAME :: 0xFC;
VK_PA1 :: 0xFD;
VK_OEM_CLEAR :: 0xFE;

WNDCLASSEXA :: struct
{
	cbSize : UINT;
	style : UINT;
	lpfnWndProc : #convention(win64) (hWnd : HANDLE, uMsg : UINT, wParam : WPARAM,
						  lParam : LPARAM) -> LRESULT;
	cbClsExtra : INT;
	cbWndExtra : INT;
	hInstance : HANDLE;
	hIcon : HANDLE;
	hCursor : HANDLE;
	hBrush : HANDLE;
	lpszMenuName : ^CHAR;
	lpszClassName : ^CHAR;
	hIconSm : HANDLE;
};
POINT :: struct
{
	x : LONG;
	y : LONG;
};
RECT :: struct
{
	left   : LONG;
	top    : LONG;
	right  : LONG;
	bottom : LONG;
};
MSG :: struct
{
	hWnd : HANDLE;
	message : UINT;
	wParam : WPARAM;
	lParam : LPARAM;
	time : DWORD;
	pt : POINT;
	lPrivate : DWORD;
};
PIXELFORMATDESCRIPTOR :: struct
{
	nSize : WORD;
	nVersion : WORD;
	dwFlags : DWORD;
	iPixelType : CHAR;
	cColorBits : CHAR;
	cRedBits : CHAR;
	cRedShift : CHAR;
	cGreenBits : CHAR;
	cGreenShift : CHAR;
	cBlueBits : CHAR;
	cBlueShift : CHAR;
	cAlphaBits : CHAR;
	cAlphaShift : CHAR;
	cAccumBits : CHAR;
	cAccumRedBits : CHAR;
	cAccumGreenBits : CHAR;
	cAccumBlueBits : CHAR;
	cAccumAlphaBits : CHAR;
	cDepthBits : CHAR;
	cStencilBits : CHAR;
	cAuxBuffers : CHAR;
	iLayerType : CHAR;
	bReserved : CHAR;
	dwLayerMask : DWORD;
	dwVisibleMask : DWORD;
	dwDamageMask : DWORD;
};
LARGE_INTEGER :: union {
	struct {
		LowPart : DWORD;
		HighPart : LONG;
	};
	QuadPart : LONGLONG;
};
GUID :: struct
{
	Data1 : u32;
	Data2 : u16;
	Data3 : u16;
	Data4 : [8] u8;
};
LUID :: struct
{
	LowPart: DWORD;
	HighPart: LONG;
};
EXCEPTION_DEBUG_INFO :: struct
{
	ExceptionRecord: EXCEPTION_RECORD;
	dwFirstChance: DWORD;
};
EXCEPTION_RECORD :: struct
{
	ExceptionCode: DWORD;
	ExceptionFlags: DWORD;
	ExceptionRecord: ^EXCEPTION_RECORD;
	ExceptionAddress: ^void;
	NumberParameters: DWORD;
	ExceptionInformation: [15] u64;
};
EXIT_PROCESS_DEBUG_INFO :: struct
{
	dwExitCode: DWORD;
};
EXIT_THREAD_DEBUG_INFO :: struct
{
	dwExitCode: DWORD;
};
LOAD_DLL_DEBUG_INFO :: struct
{
	hFile: HANDLE;
	lpBaseOfDll: ^void;
	dwDebugInfoFileOffset: DWORD;
	nDebugInfoSize: DWORD;
	lpImageName: ^void;
	fUnicode: WORD;
};
OUTPUT_DEBUG_STRING_INFO :: struct
{
	lpDebugStringData: ^CHAR;
	fUnicode: WORD;
	nDebugStringLength: WORD;
};
RIP_INFO :: struct
{
	dwError: DWORD;
	dwType: DWORD;
};
UNLOAD_DLL_DEBUG_INFO :: struct
{
	lpBaseOfDll: ^void;
};
CONTEXT :: struct #align(16)
{
	P1Home: DWORD64;
	P2Home: DWORD64;
	P3Home: DWORD64;
	P4Home: DWORD64;
	P5Home: DWORD64;
	P6Home: DWORD64;
	ContextFlags: DWORD;
	MxCsr: DWORD;
	SegCs: WORD;
	SegDs: WORD;
	SegEs: WORD;
	SegFs: WORD;
	SegGs: WORD;
	SegSs: WORD;
	EFlags: DWORD;
	Dr0: DWORD64;
	Dr1: DWORD64;
	Dr2: DWORD64;
	Dr3: DWORD64;
	Dr6: DWORD64;
	Dr7: DWORD64;
	Rax: DWORD64;
	Rcx: DWORD64;
	Rdx: DWORD64;
	Rbx: DWORD64;
	Rsp: DWORD64;
	Rbp: DWORD64;
	Rsi: DWORD64;
	Rdi: DWORD64;
	R8: DWORD64;
	R9: DWORD64;
	R10: DWORD64;
	R11: DWORD64;
	R12: DWORD64;
	R13: DWORD64;
	R14: DWORD64;
	R15: DWORD64;
	Rip: DWORD64;
	DUMMYUNIONNAME: union {
		FltSave: XMM_SAVE_AREA32;
		Q: [16] NEON128;
		D: [32] ULONGLONG;
		DUMMYSTRUCTNAME: struct {
			Header: [2] M128A;
			Legacy: [8] M128A;
			Xmm0: M128A;
			Xmm1: M128A;
			Xmm2: M128A;
			Xmm3: M128A;
			Xmm4: M128A;
			Xmm5: M128A;
			Xmm6: M128A;
			Xmm7: M128A;
			Xmm8: M128A;
			Xmm9: M128A;
			Xmm10: M128A;
			Xmm11: M128A;
			Xmm12: M128A;
			Xmm13: M128A;
			Xmm14: M128A;
			Xmm15: M128A;
		};
		S: [32] DWORD;
	};
	VectorRegister: [26] M128A;
	VectorControl: DWORD64;
	DebugControl: DWORD64;
	LastBranchToRip: DWORD64;
	LastBranchFromRip: DWORD64;
	LastExceptionToRip: DWORD64;
	LastExceptionFromRip: DWORD64;
};
XMM_SAVE_AREA32 :: struct
{
	ControlWord: WORD;
	StatusWord: WORD;
	TagWord: BYTE;
	Reserved1: BYTE;
	ErrorOpcode: WORD;
	ErrorOffset: DWORD;
	ErrorSelector: WORD;
	Reserved2: WORD;
	DataOffset: DWORD;
	DataSelector: WORD;
	Reserved3: WORD;
	MxCsr: DWORD;
	MxCsr_Mask: DWORD;
	FloatRegisters: [8] M128A;
	XmmRegisters: [16] M128A;
	Reserved4: [96] BYTE;
};
M128A :: struct
{
	Low: ULONGLONG;
	High: LONGLONG;
};
NEON128 :: struct
{
	Low: ULONGLONG;
	High: LONGLONG;
};
INPUT_RECORD :: struct
{
	EventType: WORD;
	Event: union {
		KeyEvent: KEY_EVENT_RECORD;
		WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD;
		MenuEvent: MENU_EVENT_RECORD;
		FocusEvent: FOCUS_EVENT_RECORD;
	};
};
KEY_EVENT_RECORD :: struct
{
	bKeyDown: BOOL;
	wRepeatCount: WORD;
	wVirtualKeyCode: WORD;
	wVirtualScanCode: WORD;
	uChar: union {
		UnicodeChar: WCHAR;
		AsciiChar: CHAR;
	};
	dwControlKeyState: DWORD;
};
MOUSE_EVENT_RECORD :: struct
{
	dwMousePosition: COORD;
	dwButtonState: DWORD;
	dwControlKeyState: DWORD;
	dwEventFlags: DWORD;
};
WINDOW_BUFFER_SIZE_RECORD :: struct
{
	dwSize: COORD;
};
MENU_EVENT_RECORD :: struct
{
	dwCommandId: UINT;
};
FOCUS_EVENT_RECORD :: struct
{
	bSetFocus: BOOL;
};
COORD :: struct
{
	X: SHORT;
	Y: SHORT;
};
CONSOLE_SCREEN_BUFFER_INFO :: struct
{
	dwSize: COORD;
	dwCursorPosition: COORD;
	wAttributes: WORD;
	srWindow: SMALL_RECT;
	dwMaximumWindowSize: COORD;
};
SMALL_RECT :: struct
{
	Left: SHORT;
	Top: SHORT;
	Right: SHORT;
	Bottom: SHORT;
};
PROCESS_INFORMATION :: struct
{
	hProcess: HANDLE;
	hThread: HANDLE;
	dwProcessId: DWORD;
	dwThreadId: DWORD;
};
STARTUPINFOA :: struct
{
	cb: DWORD;
	lpReserved: ^CHAR;
	lpDesktop: ^CHAR;
	lpTitle: ^CHAR;
	dwX: DWORD;
	dwY: DWORD;
	dwXSize: DWORD;
	dwYSize: DWORD;
	dwXCountChars: DWORD;
	dwYCountChars: DWORD;
	dwFillAttribute: DWORD;
	dwFlags: DWORD;
	wShowWindow: WORD;
	cbReserved2: WORD;
	lpReserved2: ^BYTE;
	hStdInput: HANDLE;
	hStdOutput: HANDLE;
	hStdError: HANDLE;
};
SECURITY_ATTRIBUTES :: struct
{
	nLength: DWORD;
	lpSecurityDescriptor: ^void;
	bInheritHandle: bool;
};
DEBUG_EVENT :: struct
{
	dwDebugEventCode: DWORD;
	dwProcessId: DWORD;
	dwThreadId: DWORD;
	u: union {
		Exception: EXCEPTION_DEBUG_INFO;
		CreateThread: CREATE_THREAD_DEBUG_INFO;
		CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO;
		ExitThread: EXIT_THREAD_DEBUG_INFO;
		ExitProcess: EXIT_PROCESS_DEBUG_INFO;
		LoadDll: LOAD_DLL_DEBUG_INFO;
		UnloadDll: UNLOAD_DLL_DEBUG_INFO;
		DebugString: OUTPUT_DEBUG_STRING_INFO;
		RipInfo: RIP_INFO;
	};
};
CREATE_PROCESS_DEBUG_INFO :: struct
{
	hFile: HANDLE;
	hProcess: HANDLE;
	hThread: HANDLE;
	lpBaseOfImage: ^void;
	dwDebugInfoFileOffset: DWORD;
	nDebugInfoSize: DWORD;
	lpThreadLocalBase: ^void;
	lpStartAddress: THREAD_START_ROUTINE;
	lpImageName: ^void;
	fUnicode: WORD;
};
CREATE_THREAD_DEBUG_INFO :: struct
{
	hThread: HANDLE;
	lpThreadLocalBase: ^void;
	lpStartAddress: THREAD_START_ROUTINE;
};

Sleep :: #external #convention(win64) (dwMilliseconds : DWORD);
OutputDebugStringA :: #external #convention(win64) (str : ^CHAR);
CreateFileA :: #external #convention(win64) (
		lpFileName : ^CHAR,
		dwDesiredAccess : DWORD,
		dwShareMode : DWORD,
		lpSecurityAttributes : ^void, // @Todo
		dwCreationDisposition : DWORD,
		dwFlagsAndAttributes : DWORD,
		hTemplateFile : HANDLE) -> HANDLE;
CloseHandle :: #external #convention(win64) (handle : HANDLE);
GetFileSize :: #external #convention(win64) (handle : HANDLE, lpFileSizeHigh : ^DWORD) -> DWORD;
ReadFile :: #external #convention(win64) (hFile : HANDLE, lpBuffer : ^void,
		nNumberOfBytesToRead : DWORD, lpNumberOfBytesRead : ^DWORD, lpOverlapped : ^void) -> BOOL;
VirtualAlloc :: #external #convention(win64) (lpAddress : ^void, dwSize : SIZE_T,
		flAllocationType : DWORD, flProtect : DWORD) -> ^void;
VirtualFree :: #external #convention(win64) (lpAddress : ^void, dwSize : SIZE_T,
		dwFreeType : DWORD) -> BOOL;
AttachConsole :: #external #convention(win64) (handle : HANDLE);
GetModuleHandleA :: #external #convention(win64) (lpModuleName : ^CHAR) -> HANDLE;
RegisterClassExA :: #external #convention(win64) (wndClass : ^WNDCLASSEXA) -> u16;
CreateWindowExA :: #external #convention(win64) (
		dwExStyle : DWORD,
		lpClassName : ^CHAR,
		lpWindowName : ^CHAR,
		dwStyle : DWORD,
		x : INT,
		y : INT,
		nWidth : INT,
		nHeight : INT,
		hWndParent : HANDLE,
		hMenu : HANDLE,
		hInstance : HANDLE,
		lpParam : ^void
	) -> HANDLE;
ShowWindow :: #external #convention(win64) (hWnd : HANDLE, nCmdShow : INT) -> BOOL;
GetLastError :: #external #convention(win64) () -> DWORD;
DefWindowProcA :: #external #convention(win64) (hWnd : HANDLE, uMsg : UINT, wParam : WPARAM,
		lParam : LPARAM) -> LRESULT;
PeekMessageA :: #external #convention(win64) (lpMsg : ^MSG, hWnd : HANDLE, wMsgFilterMin : UINT,
		wMsgFilterMax : UINT, wRemoveMsg : UINT) -> BOOL;
TranslateMessage :: #external #convention(win64) (message : ^MSG) -> BOOL;
DispatchMessageA :: #external #convention(win64) (message : ^MSG) -> LRESULT;
GetProcAddress :: #external #convention(win64) (hModule : HANDLE, lpProcName : ^CHAR) -> ^void;
GetDC :: #external #convention(win64) (hWnd : HANDLE) -> HANDLE;
ReleaseDC :: #external #convention(win64) (hWnd : HANDLE, hdc : HANDLE);
ChoosePixelFormat :: #external #convention(win64) (hdc : HANDLE, ppfd : ^PIXELFORMATDESCRIPTOR) -> INT;
SetPixelFormat :: #external #convention(win64) (hdc : HANDLE, format : INT, ppfd : ^PIXELFORMATDESCRIPTOR) -> BOOL;
PostQuitMessage :: #external #convention(win64) (nExitCode : INT);
DestroyWindow :: #external #convention(win64) (hWnd : HANDLE) -> BOOL;
TerminateProcess :: #external #convention(win64) (hProcess : HANDLE, uExitCode : UINT) -> BOOL;
TerminateThread :: #external #convention(win64) (hThread : HANDLE, uExitCode : UINT) -> BOOL;
QueryPerformanceCounter :: #external #convention(win64) (lpPerformanceCount : ^LARGE_INTEGER) -> BOOL;
QueryPerformanceFrequency :: #external #convention(win64) (lpFrequency : ^LARGE_INTEGER) -> BOOL;
AdjustWindowRect :: #external #convention(win64) (lpRect : ^RECT, dwStyle : DWORD, bMenu : BOOL) -> BOOL;
ReadConsoleInputA :: #external #convention(win64) (hConsoleInput: HANDLE, lpBuffer: ^INPUT_RECORD, nLength: DWORD,
		lpNumberOfEventsRead: ^DWORD) -> bool;
GetConsoleScreenBufferInfo :: #external #convention(win64) (hConsoleOutput: HANDLE,
		lpConsoleScreenBufferInfo: ^CONSOLE_SCREEN_BUFFER_INFO) -> bool;
SetConsoleCursorPosition :: #external #convention(win64) (hConsoleOutput: HANDLE, dwCursorPosition: COORD) -> bool;
CreateProcessA :: #external #convention(win64) (lpApplicationName: ^CHAR, lpCommandLine: ^CHAR,
		lpProcessAttributes: ^SECURITY_ATTRIBUTES, lpThreadAttributes: ^SECURITY_ATTRIBUTES, bInheritHandles: BOOL,
		dwCreationFlags: DWORD, lpEnvironment: ^void, lpCurrentDirectory: ^CHAR, lpStartupInfo: ^STARTUPINFOA,
		lpProcessInformation: ^PROCESS_INFORMATION) -> bool;
CreateThread :: #external #convention(win64) (lpThreadAttributes: ^SECURITY_ATTRIBUTES, dwStackSize: u64,
		lpStartAddress: THREAD_START_ROUTINE, lpParameter: ^void, dwCreationFlags: DWORD,
		lpThreadId: ^DWORD) -> HANDLE;
WaitForDebugEvent :: #external #convention(win64) (lpDebugEvent: ^DEBUG_EVENT, dwMilliseconds: DWORD) -> bool;
ContinueDebugEvent :: #external #convention(win64) (dwProcessId: DWORD, dwThreadId: DWORD,
		dwContinueStatus: DWORD) -> bool;
WaitForSingleObject :: #external #convention(win64) (hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
CreateMutexA :: #external #convention(win64) (lpMutexAttributes: ^SECURITY_ATTRIBUTES,
		bInitialOwner: BOOL, lpName: ^CHAR) -> HANDLE;
ReleaseMutex :: #external #convention(win64) (hHandle: HANDLE) -> BOOL;

F64HighWord :: (x : f64) -> s32
{
	union
	{
		xAsFloat : f64;
		xAsBytes : u64;
	};
	xAsFloat = x;
	return cast(s32)(xAsBytes >> 32);
}

F64LowWord :: (x : f64) -> s32
{
	union
	{
		xAsFloat : f64;
		xAsBytes : u64;
	};
	xAsFloat = x;
	return cast(s32)xAsBytes;
}

KSin :: (x : f64, y : f64, iy : s32) -> f64
{
	S1 :s f64 = -1.66666666666666324348e-01;
	S2 :s f64 =  8.33333333332248946124e-03;
	S3 :s f64 = -1.98412698298579493134e-04;
	S4 :s f64 =  2.75573137070700676789e-06;
	S5 :s f64 = -2.50507602534068634195e-08;
	S6 :s f64 =  1.58969099521155010221e-10;

	ix := F64HighWord(x) & 0x7fffffff;
	if (ix < 0x3e400000)				/* |x| < 2^-27 */
		if (cast(s32)x == 0) return x;	/* Approximate to x for small values */
	z := x * x;
	v := z * x;
	r := S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));
	if iy == 0 return x + v * (S1 + z * r);
	else	   return x - ((z * (0.5 * y - v * r) - y) - v * S1);
}

KCos :: (x : f64, y : f64) -> f64
{
	C1 :s f64 =  4.16666666666666019037e-02;
	C2 :s f64 = -1.38888888888741095749e-03;
	C3 :s f64 =  2.48015872894767294178e-05;
	C4 :s f64 = -2.75573143513906633035e-07;
	C5 :s f64 =  2.08757232129817482790e-09;
	C6 :s f64 = -1.13596475577881948265e-11;

	ix := F64HighWord(x) & 0x7fffffff;
	if ix < 0x3e400000
		if cast(s32)x == 0 return 1.0;
	z := x * x;
	r := z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));
	if ix < 0x3fd33333
		return 1.0 - (0.5 * z - (z * r - x * y));
	else
	{
		union
		{
			qx : f64;
			struct
			{
				qxLow : s32;
				qxHigh : s32;
			};
		};
		if ix > 0x3fe90000
			qx = 0.28125;
		else
		{
			qxHigh = ix - 0x00200000;
			qxLow = 0;
		}
		hz := 0.5 * z - qx;
		a := 1.0 - qx;
		return a - (hz - (z * r - x * y));
	}
}

KTan :: (x : f64, y : f64, iy : s32) -> f64
{
	PIO4   :s f64 = 7.85398163397448278999e-01; /* 3FE921FB, 54442D18 */
	PIO4LO :s f64 = 3.06161699786838301793e-17; /* 3C81A626, 33145C07 */
	T :s [13] f64 = {
		 3.33333333333334091986e-01,	/* 3FD55555, 55555563 */
		 1.33333333333201242699e-01,	/* 3FC11111, 1110FE7A */
		 5.39682539762260521377e-02,	/* 3FABA1BA, 1BB341FE */
		 2.18694882948595424599e-02,	/* 3F9664F4, 8406D637 */
		 8.86323982359930005737e-03,	/* 3F8226E3, E96E8493 */
		 3.59207910759131235356e-03,	/* 3F6D6D22, C9560328 */
		 1.45620945432529025516e-03,	/* 3F57DBC8, FEE08315 */
		 5.88041240820264096874e-04,	/* 3F4344D8, F2F26501 */
		 2.46463134818469906812e-04,	/* 3F3026F7, 1A8D1068 */
		 7.81794442939557092300e-05,	/* 3F147E88, A03792A6 */
		 7.14072491382608190305e-05,	/* 3F12B80F, 32F0A7E9 */
		-1.85586374855275456654e-05,	/* BEF375CB, DB605373 */
		 2.59073051863633712884e-05,	/* 3EFB2A70, 74BF7AD4 */
	};

	union {
		z : f64;
		struct {
			zLow  : s32;
			zHigh : s32;
		};
	};
	union {
		t : f64;
		struct {
			tLow  : s32;
			tHigh : s32;
		};
	};

	hx := F64HighWord(x);
	ix := hx & 0x7fffffff;
	w, r, v : f64;
	if ix < 0x3e300000 {			/* x < 2**-28 */
		if cast(s32)x == 0 {		/* generate inexact */
			if (((ix | F64LowWord(x)) | (iy + 1)) == 0)
				return 1.0 / FAbs64(x);
			else {
				if iy == 1
					return x;
				else {	/* compute -1 / (x+y) carefully */
					w := x + y;
					z = w;
					zLow = 0;
					v = y - (z - x);

					a := -1.0 / w;
					t = a;
					tLow = 0;
					s := 1.0 + t * z;
					return t + a * (s + t * v);
				}
			}
		}
	}
	if ix >= 0x3FE59428 {	/* |x| >= 0.6744 */
		if hx < 0 {
			x = -x;
			y = -y;
		}
		z = PIO4 - x;
		w = PIO4LO - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	w = z * z;
	/*
	 * Break x^5*(T[1]+x^2*T[2]+...) into
	 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +
		w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +
		w * T[12])))));
	s := z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if ix >= 0x3FE59428 {
		v = cast(f64)iy;
		return cast(f64)(1 - ((hx >> 30) & 2)) *
			(v - 2.0 * (x - (w * w / (w + v) - r)));
	}
	if iy == 1
		return w;
	else {
		/*
		 * if allow error up to 2 ulp, simply return
		 * -1.0 / (x+r) here
		 */
		/* compute -1.0 / (x+r) accurately */
		z = w;
		zLow = 0;
		v = r - (z - x);	/* z+v = r+x */
		a := -1.0 / w;	/* a = -1.0/w */
		t = a;
		tLow = 0;
		s = 1.0 + t * z;
		return t + a * (s + t * v);
	}
}

ReminderPiOver2 :: (x : f64, y : ^[2] f64) -> s32
{
	TWO24   :s f64 =  1.67772160000000000000e+07;
	INVPIO2 :s f64 =  6.36619772367581382433e-01;
	PIO2_1  :s f64 =  1.57079632673412561417e+00;
	PIO2_1T :s f64 =  6.07710050650619224932e-11;
	PIO2_2  :s f64 =  6.07710050630396597660e-11;
	PIO2_2T :s f64 =  2.02226624879595063154e-21;
	PIO2_3  :s f64 =  2.02226624871116645580e-21;
	PIO2_3T :s f64 =  8.47842766036889956997e-32;

	NPIO2_HW : [32] s32 = { // @Todo: make static.
		0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C, 0x4025FDBB, 0x402921FB,
		0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C, 0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB,
		0x403AB41B, 0x403C463A, 0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,
		0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB, 0x404858EB, 0x404921FB
	};

	hx := F64HighWord(x);
	ix := hx & 0x7fffffff;
	if ix <= 0x3fe921fb		/* |x| ~<= pi/4 */
	{
		y[0] = x;
		y[1] = 0;
		return 0;
	}
	if ix < 0x4002d97c		/* |x| < 3pi/4 */
	{
		if hx > 0
		{
			z := x - PIO2_1;
			if ix != 0x3ff921fb
			{
				y[0] = z - PIO2_1T;
				y[1] = (z - y[0]) - PIO2_1T;
			}
			else
			{
				z -= PIO2_2;
				y[0] = z - PIO2_2T;
				y[1] = (z - y[0]) - PIO2_2T;
			}
			return 1;
		}
		else				/* negative */
		{
			z := x + PIO2_1;
			if ix != 0x3ff921fb
			{
				y[0] = z + PIO2_1T;
				y[1] = (z - y[0]) + PIO2_1T;
			}
			else
			{
				z += PIO2_2;
				y[0] = z + PIO2_2T;
				y[1] = (z - y[0]) + PIO2_2T;
			}
			return -1;
		}
	}
	if ix <= 0x413921fb		/* |x| ~<= 2^19 * (pi/2), medium size */
	{
		t := FAbs64(x);
		n := cast(s32)(t * INVPIO2 + 0.5);
		fn := cast(f64)n;
		r := t - fn * PIO2_1;
		w := fn * PIO2_1T;
		if (n < 32 && ix != NPIO2_HW[n - 1])
			y[0] = r - w;
		else
		{
			j := ix >> 20;
			y[0] = r - w;
			i := j - ((F64HighWord(y[0]) >> 20) & 0x7ff);
			if i > 16
			{
				t = r;
				w = fn * PIO2_2;
				r = t - w;
				w = fn * PIO2_2T - ((t - r) - w);
				y[0] = r - w;
				i = j - ((F64HighWord(y[0]) >> 20) & 0x7ff);
				if i > 49
				{
					t = r;
					w = fn * PIO2_3;
					r = t - w;
					w = fn * PIO2_3T - ((t - r) - w);
					y[0] = r - w;
				}
			}
		}
		y[1] = (r - y[0]) - w;
		if hx < 0
		{
			y[0] = -y[0];
			y[1] = -y[1];
			return -n;
		}
		else
			return n;
	}
	if ix >= 0x7ff00000		/* Inf or NaN */
	{
		y[0] = x - x;
		y[1] = x - x;
		return 0;
	}
	// @Todo: big values
	Print("Big values not implemented!\n");
	return 0;
}

Sin :: (x : f64) -> f64
{
	xi := F64HighWord(x) & 0x7fffffff;
	if (xi < 0x3fe921fb)				/* |x| ~< pi/4 */
		return KSin(x, 0, 0);

	// Inf and NaN
	else if (xi >= 0x7ff00000)
		return x - x;

	else
	{
		y : [2] f64 = ?;
		n := ReminderPiOver2(x, ^y);
		result : f64 = ?;
		if n & 1
			result = KCos(y[0], y[1]);
		else
			result = KSin(y[0], y[1], 1);

		if n & 2
			return -result;
		else
			return  result;
	}
}

Cos :: (x : f64) -> f64
{
	ix := F64HighWord(x) & 0x7fffffff;
	if ix <= 0x3fe921fb
		return KCos(x, 0);

	// Inf and NaN
	else if ix >= 0x7ff00000
		return x - x;

	else
	{
		y : [2] f64 = ?;
		n := ReminderPiOver2(x, ^y);
		if	  ((n & 3) == 0)
			return  KCos(y[0], y[1]);
		else if ((n & 3) == 1)
			return -KSin(y[0], y[1], 1);
		else if ((n & 3) == 2)
			return -KCos(y[0], y[1]);
		else
			return  KSin(y[0], y[1], 1);
	}
}

Tan :: (x : f64) -> f64
{
	/* High word of x. */
	ix := F64HighWord(x);

	/* |x| ~< pi/4 */
	ix &= 0x7fffffff;
	if ix <= 0x3fe921fb return KTan(x, 0, 1);

	/* tan(Inf or NaN) is NaN */
	else if ix >= 0x7ff00000 return x-x;		/* NaN */

	/* argument reduction needed */
	else {
		y : [2] f64 = ?;
		n := ReminderPiOver2(x, ^y);
		return KTan(y[0], y[1], 1-((n&1)<<1)); /*   1 -- n even
							-1 -- n odd */
	}
}

Sqrt32 :: #inline (n : f32) -> f32
{
	#intrinsic(sqrt32, n, n);
	return n;
}

Sqrt64 :: #inline (n : f64) -> f64
{
	#intrinsic(sqrt64, n, n);
	return n;
}

FAbs64 :: (n : f64) -> f64
{
	union
	{
		nAsFloat : f64;
		nAsBytes : u64;
	};
	union
	{
		resultAsFloat : f64;
		resultAsBytes : u64;
	};
	nAsFloat = n;
	resultAsBytes = nAsBytes & 0x7fffffffffffffff;
	return resultAsFloat;
}

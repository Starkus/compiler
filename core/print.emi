PrintF :: (format : String, ..args)
{
	PrintArgument :: (arg : Any)
	{
		if arg.typeInfo == typeof(String)
		{
			//Print(@ cast(^String) arg.data);
			str : String = @ cast(^String) arg.data;
			Print(str);
		}
		else if arg.typeInfo.typeKind == TypeKind_Integer
		{
			intInfo := cast(^TypeInfoInteger) arg.typeInfo;
			num : s64;
			if intInfo.size == 1
				num = @ cast(^s8) arg.data;
			else if intInfo.size == 2
				num = @ cast(^s16) arg.data;
			else if intInfo.size == 4
				num = @ cast(^s32) arg.data;
			else if intInfo.size == 8
				num = @ cast(^s64) arg.data;

			buffer : [16] u8;
			n := num;
			count := 0;
			while 1
			{
				digit := n % 10;
				buffer[15 - count] = cast(u8) digit + '0';
				count += 1;

				n /= 10;
				if n <= 0 break;
			}
			numStr : String;
			numStr.size = cast(u64) count;
			numStr.data = ^buffer[16 - count];
			Print(numStr);
		}
		else if arg.typeInfo.typeKind == TypeKind_Floating
		{
			f : f64;
			if arg.typeInfo.size == 4
				f = @ cast(^f32) arg.data;
			else if arg.typeInfo.size == 8
				f = @ cast(^f64) arg.data;

			// Cheat
			buffer : [32] u8;
			count := 0;

			// Fraction
			n : s64 = f * 10000000;
			for 0..7
			{
				digit := n % 10;
				buffer[31 - count] = cast(u8) digit + '0';
				count += 1;
				n /= 10;
			}
			buffer[31 - count] = '.';
			count += 1;

			// Wholes
			n = f;
			while n > 0
			{
				digit := n % 10;
				buffer[31 - count] = cast(u8) digit + '0';
				count += 1;
				n /= 10;
			}
			numStr : String;
			numStr.size = cast(u64) count;
			numStr.data = ^buffer[32 - count];
			Print(numStr);
		}
		else if arg.typeInfo.typeKind == TypeKind_Struct
		{
			structInfo := cast(^TypeInfoStruct) arg.typeInfo;
			Print("{ ");
			for structInfo.members
			{
				member : Any;
				member.typeInfo = it.typeInfo;
				member.data = arg.data + it.offset;

				buffer : [128] u8;
				str : String;
				str.data = ^buffer[0];
				str.size = 0;
				if i > 0
				{
					@(cast(^u32) str.data) = 0x202C;
					str.size = 2;
				}
				for it.name
				{
					buffer[str.size] = @it;
					str.size += 1;
				}
				@(cast(^u32) str.data + str.size) = 0x203A;
				str.size += 2;
				Print(str);
				PrintArgument(member);
			}
			Print(" }");
		}
		else if arg.typeInfo.typeKind == TypeKind_Enum
		{
			enumInfo := cast(^TypeInfoEnum) arg.typeInfo;
			num := @ cast(^s64) arg.data;
			for (enumInfo.values)
			{
				if @it == num
				{
					Print(enumInfo.names[i]);
					break;
				}
			}
		}
		else if arg.typeInfo.typeKind == TypeKind_Array
		{
			arrayInfo := cast(^TypeInfoArray) arg.typeInfo;
			Print("{ ");
			element : Any;
			element.typeInfo = arrayInfo.elementTypeInfo;
			elementSize := arrayInfo.elementTypeInfo.size;
			buffer : ^u8 = cast(^u8) arg.data;
			count : u64 = arrayInfo.count;
			if count == 0
			{
				count = @ cast(^u64) arg.data;
				buffer = @ cast(^^u8) arg.data + 8;
			}
			for 0..count
			{
				if i > 0 Print(", ");
				element.data = buffer + i * elementSize;
				PrintArgument(element);
			}
			Print(" }");
		}
		else if arg.typeInfo.typeKind == TypeKind_Pointer
		{
			pointerInfo := cast(^TypeInfoPointer) arg.typeInfo;
			Print("^");
			pointedThing : Any;
			pointedThing.typeInfo = pointerInfo.typeInfo;
			pointedThing.data = @ cast(^^void) arg.data;
			PrintArgument(pointedThing);
		}
		else
			Print("<Unknown type>");
	}

	stdOut := GetStdHandle(-11);
	bytesWritten : s64;
	argIdx := 0;
	for (0..format.size)
	{
		char : u8 = format[i];
		if char == '%'
		{
			PrintArgument(args[argIdx]);
			argIdx += 1;
		}
		else
		{
			WriteFile(stdOut, ^char, 1, ^bytesWritten, 0);
		}
	}
}

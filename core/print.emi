PrintF :: (format : String, ..args)
{
	PrintArgument :: (arg : Any) {
		typeInfo := arg.typeInfo;
		while typeInfo.typeKind == TypeKind_Alias {
			aliasInfo := cast(^TypeInfoAlias)typeInfo;
			typeInfo = aliasInfo.typeInfo;
		}

		if typeInfo == typeof(String)
			Print(@ cast(^String) arg.data);
		else if typeInfo == typeof(Any) {
			any := cast(^Any) arg.data;
			PrintArgument(@any);
		}
		else if typeInfo.typeKind == TypeKind_Integer {
			intInfo := cast(^TypeInfoInteger) typeInfo;
			num : u64;
			isNegative : bool = false;

			if intInfo.isSigned {
				signedNum : s64;
				if intInfo.size == 1
					signedNum = arg.asS8;
				else if intInfo.size == 2
					signedNum = arg.asS16;
				else if intInfo.size == 4
					signedNum = arg.asS32;
				else if intInfo.size == 8
					signedNum = arg.asS64;
				if signedNum < 0 {
					signedNum = -signedNum;
					isNegative = true;
				}
				num = cast(u64)signedNum;
			}
			else {
				if intInfo.size == 1
					num = arg.asU8;
				else if intInfo.size == 2
					num = arg.asU16;
				else if intInfo.size == 4
					num = arg.asU32;
				else if intInfo.size == 8
					num = arg.asU64;
			}

			buffer : [20] u8;
			n := num;
			count := 0;
			while 1 {
				digit := n % 10;
				buffer[19 - count] = cast(u8) digit + '0';
				count += 1;

				n /= 10;
				if n <= 0 break;
			}

			if isNegative {
				buffer[19 - count] = '-';
				count += 1;
			}

			numStr : String;
			numStr.size = cast(u64) count;
			numStr.data = ^buffer[20 - count];
			Print(numStr);
		}
		else if typeInfo.typeKind == TypeKind_Floating {
			f : f64 = ?;
			if typeInfo.size == 4
				f = arg.asF32;
			else if typeInfo.size == 8
				f = arg.asF64;

			// Cheat
			buffer : [32] u8;
			count := 0;

			isNegative : bool = false;
			if f < 0 {
				isNegative = true;
				f = -f;
			}

			// Fraction
			n : s64 = f * 10000000.0 + 0.5;
			start : bool = false;
			for 0..7 {
				digit := n % 10;
				if digit > 0 start = true;
				if start || i == 6 {
					buffer[31 - count] = cast(u8) digit + '0';
					count += 1;
				}
				n /= 10;
			}
			buffer[31 - count] = '.';
			count += 1;

			// Wholes
			n = f;
			while true {
				digit := n % 10;
				buffer[31 - count] = cast(u8) digit + '0';
				count += 1;
				n /= 10;
				if n <= 0 break;
			}
			if isNegative {
				buffer[31 - count] = '-';
				count += 1;
			}
			numStr : String = { cast(u64) count, ^buffer[32 - count] };
			Print(numStr);
		}
		else if typeInfo.typeKind == TypeKind_Struct {
			structInfo := cast(^TypeInfoStruct) typeInfo;
			Print("{ ");
			for structInfo.members {
				memberPtr : ^void = arg.data + it.offset;

				memberType := it.typeInfo;
				while memberType.typeKind == TypeKind_Alias {
					aliasInfo := cast(^TypeInfoAlias)memberType;
					memberType = aliasInfo.typeInfo;
				}

				member : Any = { memberType, memberPtr };
				if memberType.typeKind == TypeKind_Integer ||
				   memberType.typeKind == TypeKind_Floating ||
				   memberType.typeKind == TypeKind_Enum ||
				   memberType.typeKind == TypeKind_Pointer
					member.asU64 = @cast(^u64)memberPtr;

				buffer : [128] u8 = ?;
				str : String = { 0, ^buffer[0] };
				if i > 0 {
					@(cast(^u32) str.data) = 0x202C;
					str.size = 2;
				}
				for it.name {
					buffer[str.size] = @it;
					str.size += 1;
				}

				// Insert ", "
				@(cast(^u32) str.data + str.size) = 0x203A;
				str.size += 2;

				Print(str);
				PrintArgument(member);
			}
			Print(" }");
		}
		else if typeInfo.typeKind == TypeKind_Enum {
			enumInfo := cast(^TypeInfoEnum) typeInfo;
			num := arg.asS64;
			for (enumInfo.values) {
				if @it == num {
					Print(enumInfo.names[i]);
					return;
				}
			}
			// Default to printing the number
			Print("?(");
			PrintArgument(num);
			Print(")");
		}
		else if typeInfo.typeKind == TypeKind_Array {
			arrayInfo := cast(^TypeInfoArray) typeInfo;
			Print("{ ");
			element : Any = ?;
			element.typeInfo = arrayInfo.elementTypeInfo;
			elementSize := arrayInfo.elementTypeInfo.size;
			buffer : ^u8 = cast(^u8)arg.data;
			count : u64 = arrayInfo.count;
			if count == 0 {
				count = @ cast(^u64) buffer;
				buffer = @ (cast(^^u8) buffer + 8);
			}
			Print("[");
			PrintArgument(count);
			Print("] ");
			for 0..count {
				if i > 0 Print(", ");

				element.data = buffer + cast(u64)i * elementSize;
				if element.typeInfo.typeKind == TypeKind_Integer ||
				   element.typeInfo.typeKind == TypeKind_Floating ||
				   element.typeInfo.typeKind == TypeKind_Enum ||
				   element.typeInfo.typeKind == TypeKind_Pointer
					element.data = @cast(^u64)element.data;

				PrintArgument(element);
				if i > 32 {
					Print("...");
					break;
				}
			}
			Print(" }");
		}
		else if typeInfo.typeKind == TypeKind_Pointer ||
				typeInfo.typeKind == TypeKind_ProcedurePointer
		{
			pointer : u64 = arg.asU64;
			if pointer == null
				Print("null");
			else {
				buffer : [18] u8 = ?;
				buffer[0] = '0';
				buffer[1] = 'x';
				for 0..16 {
					digit := cast(u8)(pointer & 0xF);
					if digit <= 9
						buffer[17 - i] = '0' + digit;
					else
						buffer[17 - i] = 'A' - 0xA + digit;
					pointer >>= 4;
				}
				string : String = { 18, ^buffer };
				Print(string);
			}
		}
		else
			Print("<Unknown type>");
	}

	str : String = { 0, format.data };
	argIdx := 0;
	for (0..format.size) {
		char : u8 = format[i];
		if char == '%' {
			Print(str);
			PrintArgument(args[argIdx]);
			argIdx += 1;
			str.size = 0;
			str.data = ^format[i+1];
		}
		else {
			str.size += 1;
		}
	}
	Print(str);
}

ToHex :: (num : u64, buffer : ^u8) -> String
{
	letterOffset :: 'A' - 10;
	cursor := buffer + 15;
	count : u64 = 0;
	for 0..16 {
		digit : u8 = cast(u8)(num & 0xF); // num % 16
		if digit > 9
			@cursor = letterOffset + digit;
		else
			@cursor = '0' + digit;
		num >>= 4; // num /= 16
		cursor -= 1;
		count += 1;
	}
	return { count, buffer };
}

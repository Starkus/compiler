compiler_platform :: COMPILER_PLATFORM_WINDOWS;

GetCommandLineA :: #external #convention(win64) () -> ^s8;
GetStdHandle :: #external #convention(win64) (handle: s64) -> s64;
WriteFile :: #external #convention(win64) (handle: s64, buffer: ^void, bytesToWrite: s64,
		bytesWritten: ^s64, overlapped: ^void) -> bool;
ExitProcess :: #external #convention(win64) (uExitCode : u32);

Print :: (string: String)
{
	stdOut := GetStdHandle(-11);
	bytesWritten: s64 = ?;
	WriteFile(stdOut, string.data, cast(s64) string.size, ^bytesWritten, 0);
}

Assert :: (expr: bool)
{
	if !expr {
		// @Todo: somehow pass caller file and line
		Print("Assert failed!\n");
		Breakpoint();
		ExitProcess(1);
	}
}

#if compiler_output_type == COMPILER_OUTPUT_EXECUTABLE
__WindowsMain :: #export ()
{
	cmdLineCStr := GetCommandLineA();
	args : [] String;
	argsBuffer : [64] String = ?;
	args.data = ^argsBuffer;

	scan := cast(^u8)cmdLineCStr;
	word := scan;
	while (args.size < 64) {
		if @scan == ' ' || @scan == '\t' || @scan == '\n' || @scan == '\r' {
			size := scan - word;
			if size > 0 {
				argsBuffer[args.size] = { size, word };
				args.size += 1;
			}
			scan += 1;
			word = scan;
		}
		else if @scan == 0 {
			size := scan - word;
			if size > 0 {
				argsBuffer[args.size] = { size, word };
				args.size += 1;
			}
			break;
		}
		else
			scan += 1;
	}

	errorCode : s64 = Main(args);
	ExitProcess(cast(u32)errorCode);
}

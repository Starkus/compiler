#include "core/windows.emi";
#include "core/directx11.emi";
#include "core/vector.emi";
#linklib "d3d11.lib";
#linklib "d3dcompiler.lib";

SCREEN_WIDTH  :: 800;
SCREEN_HEIGHT :: 600;
SAMPLE_COUNT :: 4;

g_windowHandle :s HANDLE;

g_swapChain :s ^IDXGISwapChain;
g_device :s ^ID3D11Device;
g_deviceContext :s ^ID3D11DeviceContext;
g_backBuffer :s ^ID3D11RenderTargetView;
g_depthBuffer :s ^ID3D11DepthStencilView;
g_depthStencilState :s ^ID3D11DepthStencilState;
g_rasterizerState :s ^ID3D11RasterizerState;
g_vertexShader :s ^ID3D11VertexShader;
g_pixelShader :s ^ID3D11PixelShader;
g_computeShader :s ^ID3D11ComputeShader;
g_vertexBuffer :s ^ID3D11Buffer;
g_indexBuffer :s ^ID3D11Buffer;
g_constantBuffer :s ^ID3D11Buffer;
g_constantBufferModel :s ^ID3D11Buffer;
g_computeOutputBuffer :s ^ID3D11Buffer;
g_inputLayout :s ^ID3D11InputLayout;

g_vertices :s [8] Vertex = {
	{ -0.5,-0.5, 0.5,  1.0, 0.0, 0.0, 1.0 },
	{  0.5,-0.5, 0.5,  0.0, 1.0, 0.0, 1.0 },
	{ -0.5, 0.5, 0.5,  0.0, 0.0, 1.0, 1.0 },
	{  0.5, 0.5, 0.5,  0.0, 1.0, 1.0, 1.0 },
	{ -0.5,-0.5,-0.5,  1.0, 0.0, 1.0, 1.0 },
	{  0.5,-0.5,-0.5,  0.0, 1.0, 1.0, 1.0 },
	{ -0.5, 0.5,-0.5,  1.0, 1.0, 1.0, 1.0 },
	{  0.5, 0.5,-0.5,  0.0, 0.0, 0.0, 1.0 }
};
g_indices :s [36] u16 = {
	0, 2, 1, 1, 2, 3,
	4, 5, 6, 5, 7, 6,
	0, 1, 4, 4, 1, 5,
	0, 4, 2, 2, 4, 6,
	2, 6, 3, 3, 6, 7,
	1, 3, 5, 5, 3, 7
};

g_camAngle :s f32;

Vertex :: struct
{
	position: v3;
	color: v4;
};

Main :: (args : [] String) -> s64
{
	error : s64;

	error = InitWindow();
	if error return error;

	error = InitD3D();
	if error return error;

	largeInteger : LARGE_INTEGER;
	QueryPerformanceCounter(^largeInteger);
	lastPerfCounter : u64 = largeInteger.LowPart;

	QueryPerformanceFrequency(^largeInteger);
	perfFrequency : u64 = largeInteger.LowPart;

	message : MSG;
	while (true) {
		if (PeekMessageA(^message, null, 0, 0, PM_REMOVE)) {
			TranslateMessage(^message);
			DispatchMessageA(^message);

			if (message.message == WM_QUIT)
				break;
			else if message.message == WM_KEYDOWN || message.message == WM_KEYUP {
				isDown : bool = (message.lParam & (1 << 31)) == 0;
				if message.wParam == 'Q' || message.wParam == VK_ESCAPE
					break;
			}
		}
		else {
			QueryPerformanceCounter(^largeInteger);
			newPerfCounter : u64 = largeInteger.LowPart;
			deltaTime : f32 = cast(f32)(newPerfCounter - lastPerfCounter) / cast(f32)perfFrequency;

			Update(deltaTime);
			Render();

			lastPerfCounter = newPerfCounter;
		}
	}

	CleanD3D();
	return 0;
}

Update :: (deltaTime : f32)
{
	g_camAngle += deltaTime;
	while (g_camAngle > PI2)
		g_camAngle -= PI2;
}

Render :: ()
{
	clearColor : v4 = { 0.0, 0.2, 0.4, 1.0 };
	g_deviceContext.vtbl.ClearRenderTargetView(g_deviceContext, g_backBuffer,
			clearColor.v);
	g_deviceContext.vtbl.ClearDepthStencilView(g_deviceContext, g_depthBuffer,
			D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1, 0);

	unorderedAccessViewDesc : D3D11_UNORDERED_ACCESS_VIEW_DESC;
	unorderedAccessViewDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	unorderedAccessViewDesc.Format = DXGI_FORMAT_R32_FLOAT;
	unorderedAccessViewDesc.Buffer.NumElements = 64;

	unorderedAccessView : ^ID3D11UnorderedAccessView;
	g_device.vtbl.CreateUnorderedAccessView(g_device,
			cast(^ID3D11Resource)g_computeOutputBuffer, ^unorderedAccessViewDesc,
			^unorderedAccessView);
	g_deviceContext.vtbl.CSSetUnorderedAccessViews(g_deviceContext, 0, 1, ^unorderedAccessView,
			null);
	g_deviceContext.vtbl.Dispatch(g_deviceContext, 1, 1, 1);

	aNull : ^ID3D11UnorderedAccessView;
	g_deviceContext.vtbl.CSSetUnorderedAccessViews(g_deviceContext, 0, 1, ^aNull, null);

	unorderedAccessView.vtbl.Release(unorderedAccessView);

	#if 0
		DebugPrintOutputBuffer(g_computeOutputBuffer);

	// Draw
	modelMatrixMap: D3D11_MAPPED_SUBRESOURCE;
	g_deviceContext.vtbl.Map(g_deviceContext, cast(^ID3D11Resource)g_constantBufferModel, 0,
			D3D11_MAP_WRITE_DISCARD, 0, ^modelMatrixMap);
	{
		fw : v3 = { Sin(g_camAngle), Cos(g_camAngle), 0 };
		z : v3 = { 0, 0, 1 };
		right : v3 = V3Normalize(V3Cross(fw, z));
		up : v3 = V3Cross(right, fw);
		@cast(^mat4)modelMatrixMap.pData =
		{
			right.x,	right.y,	right.z,	0.0,
			fw.x,		fw.y,		fw.z,		0.0,
			up.x,		up.y,		up.z,		0.0,
			0.0,		0.0,		0.0,		1.0
		};
	}
	g_deviceContext.vtbl.Unmap(g_deviceContext, cast(^ID3D11Resource)g_constantBufferModel, 0);

	stride := cast(u32)sizeof(Vertex);
	offset : u32;
	g_deviceContext.vtbl.IASetVertexBuffers(g_deviceContext, 0, 1, ^g_computeOutputBuffer,
			^stride, ^offset);
	g_deviceContext.vtbl.IASetIndexBuffer(g_deviceContext, g_indexBuffer,
			DXGI_FORMAT_R16_UINT, 0);
	g_deviceContext.vtbl.IASetPrimitiveTopology(g_deviceContext,
			D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	g_deviceContext.vtbl.DrawIndexed(g_deviceContext, 36, 0, 0);

	g_swapChain.vtbl.Present(g_swapChain, 0, 0);
}

InitWindow :: () -> s64
{
	WindowProc :: #convention(win64) (g_windowHandle : HANDLE, message : UINT, wParam : WPARAM,
			lParam : LPARAM) -> LRESULT
	{
		if message == WM_CLOSE
			PostQuitMessage(0);
		else if message == WM_SIZE {
			// @Todo
		}
		else
			return DefWindowProcA(g_windowHandle, message, wParam, lParam);

		return 0;
	}

	hInstance := ^__ImageBase;
	windowClassName := #cstr "window";
	windowTitle := #cstr "Hello DirectX11!";

	windowClass : WNDCLASSEXA;
	windowClass.cbSize = cast(u32)sizeof(WNDCLASSEXA);
	windowClass.style = CS_HREDRAW | CS_VREDRAW;
	windowClass.lpfnWndProc = WindowProc;
	windowClass.hInstance = hInstance;
	windowClass.lpszClassName = windowClassName;

	RegisterClassExA(^windowClass);

	windowRect : RECT = { 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT };
	AdjustWindowRect(^windowRect, WS_OVERLAPPEDWINDOW, false);

	g_windowHandle = CreateWindowExA(0,
			windowClassName,
			windowTitle,
			WS_OVERLAPPEDWINDOW,
			100,
			100,
			SCREEN_WIDTH,
			SCREEN_HEIGHT,
			null,
			null,
			hInstance,
			null);
	ShowWindow(g_windowHandle, SW_SHOW);

	return 0;
}

InitD3D :: () -> s64
{
	errorCode : HRESULT;

	// Swap chain
	swapChainDesc : DXGI_SWAP_CHAIN_DESC;
	swapChainDesc.BufferCount = 1;
	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	swapChainDesc.BufferDesc.Width = SCREEN_WIDTH;
	swapChainDesc.BufferDesc.Height = SCREEN_HEIGHT;
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.OutputWindow = g_windowHandle;
	swapChainDesc.SampleDesc.Count = SAMPLE_COUNT;
	swapChainDesc.Windowed = true;
	swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	//swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	errorCode = D3D11CreateDeviceAndSwapChain(
			null,
			D3D_DRIVER_TYPE_HARDWARE,
			null,
			D3D11_CREATE_DEVICE_DEBUG,
			null,
			0,
			D3D11_SDK_VERSION,
			^swapChainDesc,
			^g_swapChain,
			^g_device,
			null,
			^g_deviceContext);
	if (errorCode != S_OK) {
		PrintF("Error creating device and swap chain: %\n", errorCode);
		return 1;
	}

	// Setup back buffer
	backBufferTexture : ^ID3D11Texture2D;
	g_swapChain.vtbl.GetBuffer(g_swapChain, 0, ^IID_ID3D11Texture2D, ^backBufferTexture);

	g_device.vtbl.CreateRenderTargetView(g_device, cast(^ID3D11Resource)backBufferTexture,
			null, ^g_backBuffer);
	backBufferTexture.vtbl.Release(backBufferTexture);

	depthStencilDesc : D3D11_DEPTH_STENCIL_DESC;
	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;
	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;
	depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
	depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	g_device.vtbl.CreateDepthStencilState(g_device, ^depthStencilDesc, ^g_depthStencilState);
	g_deviceContext.vtbl.OMSetDepthStencilState(g_deviceContext, g_depthStencilState, 1);

	depthTextureDesc : D3D11_TEXTURE2D_DESC;
	depthTextureDesc.Width = SCREEN_WIDTH;
	depthTextureDesc.Height = SCREEN_HEIGHT;
	depthTextureDesc.MipLevels = 1;
	depthTextureDesc.ArraySize = 1;
	depthTextureDesc.SampleDesc.Count = SAMPLE_COUNT;
	depthTextureDesc.Format = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;
	depthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
	depthTextureDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

	depthStencilTexture : ^ID3D11Texture2D;
	g_device.vtbl.CreateTexture2D(g_device, ^depthTextureDesc, null, ^depthStencilTexture);

	depthStencilViewDesc : D3D11_DEPTH_STENCIL_VIEW_DESC;
	depthStencilViewDesc.Format = depthTextureDesc.Format;
	depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS;

	errorCode = g_device.vtbl.CreateDepthStencilView(g_device,
			cast(^ID3D11Resource)depthStencilTexture, ^depthStencilViewDesc, ^g_depthBuffer);
	if (errorCode != S_OK) {
		PrintF("Error creating depth stencil view: %\n", errorCode);
		return 1;
	}
	depthStencilTexture.vtbl.Release(depthStencilTexture);

	g_deviceContext.vtbl.OMSetRenderTargets(g_deviceContext, 1, ^g_backBuffer, g_depthBuffer);

	// Rasterizer state
	rasterizerDesc : D3D11_RASTERIZER_DESC;
	rasterizerDesc.FillMode = D3D11_FILL_SOLID;
	rasterizerDesc.CullMode = D3D11_CULL_BACK; // @Todo: enable backface culling
	rasterizerDesc.DepthClipEnable = true;
	errorCode = g_device.vtbl.CreateRasterizerState(g_device, ^rasterizerDesc, ^g_rasterizerState);
	if (errorCode != S_OK) {
		PrintF("Error creating rasterizer state: %\n", errorCode);
		return 1;
	}

	g_deviceContext.vtbl.RSSetState(g_deviceContext, g_rasterizerState);

	// Set viewport
	viewport : D3D11_VIEWPORT;
	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.Width = SCREEN_WIDTH;
	viewport.Height = SCREEN_HEIGHT;
	viewport.MinDepth = 0;
	viewport.MaxDepth = 1;

	g_deviceContext.vtbl.RSSetViewports(g_deviceContext, 1, ^viewport);

	// Shaders
	vertexShaderBlob, pixelShaderBlob, computeShaderBlob, errorBlob : ^ID3D10Blob;

	flags : UINT = D3DCOMPILE_DEBUG;

	shaderName := "examples/shader.hlsl";
	shaderNameAsStupidWideString : [64] WCHAR;
	for shaderName
		shaderNameAsStupidWideString[i] = cast(WCHAR)@it;

	errorCode = D3DCompileFromFile(^shaderNameAsStupidWideString, null, null,
			#cstr "VShader", #cstr "vs_4_0", flags, 0, ^vertexShaderBlob, ^errorBlob);
	if (errorCode != S_OK) {
		PrintF("Error compiling vertex shader: %\n", errorCode);
		PrintErrorBlob(errorBlob);
		return 1;
	}

	errorCode = D3DCompileFromFile(^shaderNameAsStupidWideString, null, null,
			#cstr "PShader", #cstr "ps_4_0", flags, 0, ^pixelShaderBlob, ^errorBlob);
	if (errorCode != S_OK) {
		PrintF("Error compiling pixel shader: %\n", errorCode);
		PrintErrorBlob(errorBlob);
		return 1;
	}

	errorCode = D3DCompileFromFile(^shaderNameAsStupidWideString, null, D3D_COMPILE_STANDARD_FILE_INCLUDE,
			#cstr "CShader", #cstr "cs_5_0", flags, 0, ^computeShaderBlob, ^errorBlob);
	if (errorCode != S_OK) {
		PrintF("Error compiling compute shader: %\n", errorCode);
		PrintErrorBlob(errorBlob);
		return 1;
	}

	errorCode = g_device.vtbl.CreateVertexShader(g_device,
			vertexShaderBlob.vtbl.GetBufferPointer(vertexShaderBlob),
			vertexShaderBlob.vtbl.GetBufferSize(vertexShaderBlob), 
			null, ^g_vertexShader);
	errorCode = g_device.vtbl.CreatePixelShader(g_device,
			pixelShaderBlob.vtbl.GetBufferPointer(pixelShaderBlob),
			pixelShaderBlob.vtbl.GetBufferSize(pixelShaderBlob), 
			null, ^g_pixelShader);
	errorCode = g_device.vtbl.CreateComputeShader(g_device,
			computeShaderBlob.vtbl.GetBufferPointer(computeShaderBlob),
			computeShaderBlob.vtbl.GetBufferSize(computeShaderBlob), 
			null, ^g_computeShader);

	g_deviceContext.vtbl.VSSetShader(g_deviceContext, g_vertexShader,  0, 0);
	g_deviceContext.vtbl.PSSetShader(g_deviceContext, g_pixelShader,   0, 0);
	g_deviceContext.vtbl.CSSetShader(g_deviceContext, g_computeShader, 0, 0);

	// Input layout
	inputElementsDesc: [2] D3D11_INPUT_ELEMENT_DESC = {
		{ #cstr "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,  D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ #cstr "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
	};
	g_device.vtbl.CreateInputLayout(g_device, ^inputElementsDesc, 2,
			vertexShaderBlob.vtbl.GetBufferPointer(vertexShaderBlob),
			vertexShaderBlob.vtbl.GetBufferSize(vertexShaderBlob), ^g_inputLayout);

	g_deviceContext.vtbl.IASetInputLayout(g_deviceContext, g_inputLayout);


	// Vertex buffer
	bufferDesc: D3D11_BUFFER_DESC;
	bufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	bufferDesc.ByteWidth = cast(UINT)sizeof(g_vertices);
	bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	vertexData : D3D11_SUBRESOURCE_DATA;
	vertexData.pSysMem = ^g_vertices;

	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, ^vertexData, ^g_vertexBuffer);

	// Index buffer
	bufferDesc = {};
	bufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	bufferDesc.ByteWidth = cast(UINT)sizeof(g_indices);
	bufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	indexData : D3D11_SUBRESOURCE_DATA;
	indexData.pSysMem = ^g_indices;

	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, ^indexData, ^g_indexBuffer);

	// Constant buffer
	matrices: struct {
		projection: mat4;
		view: mat4;
	};
	{
		fov: f32 = HALFPI;
		near: f32 = 0.01;
		far: f32 = 2000.0;
		aspectRatio: f32 = (cast(f32)SCREEN_WIDTH / cast(f32)SCREEN_HEIGHT);

		top: f32 = 1.0 / Tan(HALFPI - fov * 0.5);
		right: f32 = top / aspectRatio;

		matrices.projection = {
			right, 0.0, 0.0, 0.0,
			0.0, top, 0.0, 0.0,
			0.0, 0.0, far/(far - near), 1.0,
			0.0, 0.0, -far * near/(far - near), 0.0
		};
	}
	{
		pos: v3 = { -2, -2, 1 };
		camFw: v3 = V3Normalize(V3Negate(pos));
		z: v3 = { 0, 0, 1 };
		right: v3 = V3Normalize(V3Cross(camFw, z));
		up: v3 = V3Cross(right, camFw);
		invViewMatrix: mat4 = {
			right.x,	right.y,	right.z,	0.0,
			up.x,		up.y,		up.z,		0.0,
			camFw.x,	camFw.y,	camFw.z,	0.0,
			pos.x,		pos.y,		pos.z,		1.0
		};

		matrices.view = Mat4Inverse(invViewMatrix);
	}

	bufferDesc = {};
	bufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	bufferDesc.ByteWidth = cast(UINT)sizeof(matrices);
	bufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	matricesData: D3D11_SUBRESOURCE_DATA;
	matricesData.pSysMem = ^matrices;

	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, ^matricesData, ^g_constantBuffer);
	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, null, ^g_constantBufferModel);

	g_deviceContext.vtbl.VSSetConstantBuffers(g_deviceContext, 0, 1, ^g_constantBuffer);
	g_deviceContext.vtbl.VSSetConstantBuffers(g_deviceContext, 1, 1, ^g_constantBufferModel);

	// Output buffer
	bufferDesc = {};
	bufferDesc.ByteWidth = 64 * 4;
	bufferDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_VERTEX_BUFFER;
	bufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS;
	bufferDesc.StructureByteStride = 4;

	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, null, ^g_computeOutputBuffer);

	return 0;
}

CleanD3D :: ()
{
	g_swapChain.vtbl.SetFullscreenState(g_swapChain, false, null);

	g_vertexShader.vtbl.Release(g_vertexShader);
	g_pixelShader.vtbl.Release(g_pixelShader);
	g_swapChain.vtbl.Release(g_swapChain);
	g_backBuffer.vtbl.Release(g_backBuffer);
	g_device.vtbl.Release(g_device);
	g_deviceContext.vtbl.Release(g_deviceContext);
}

PrintErrorBlob :: (errorBlob : ^ID3D10Blob)
{
	if errorBlob != null {
		len := errorBlob.vtbl.GetBufferSize(errorBlob);
		data := cast(^u8) errorBlob.vtbl.GetBufferPointer(errorBlob);
		string : String = { len, data };
		Print(string);
	}
}

DebugPrintOutputBuffer :: (outputBuffer: ^ID3D11Buffer)
{
	debugBuffer : ^ID3D11Buffer;
	bufferDesc : D3D11_BUFFER_DESC;
	outputBuffer.vtbl.GetDesc(outputBuffer, ^bufferDesc);
	bufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	bufferDesc.Usage = D3D11_USAGE_STAGING;
	bufferDesc.BindFlags = cast(D3D11_BIND_FLAG)0;
	bufferDesc.MiscFlags = cast(D3D11_RESOURCE_MISC_FLAG)0;

	g_device.vtbl.CreateBuffer(g_device, ^bufferDesc, null, ^debugBuffer);
	g_deviceContext.vtbl.CopyResource(g_deviceContext, cast(^ID3D11Resource)debugBuffer,
			cast(^ID3D11Resource)outputBuffer);

	mappedSubresource : D3D11_MAPPED_SUBRESOURCE;
	g_deviceContext.vtbl.Map(g_deviceContext, cast(^ID3D11Resource)debugBuffer, 0,
			D3D11_MAP_READ, 0, ^mappedSubresource);

	for 0 .. bufferDesc.ByteWidth / 4
		PrintF("%, ", (cast([1]f32)mappedSubresource.pData)[i]);
	Print("\n\n");

	g_deviceContext.vtbl.Unmap(g_deviceContext, cast(^ID3D11Resource)debugBuffer, 0);
	debugBuffer.vtbl.Release(debugBuffer);
}

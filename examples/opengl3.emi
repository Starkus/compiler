#include "core/basic.emi";
#include "core/print.emi";
#include "core/glh.emi";
#include "core/vector.emi";
#include "core/math.emi";

compiler_subsystem :: COMPILER_SUBSYSTEM_WINDOWS;

g_running :s bool = true;
g_windowHandle :s ^void;
g_deviceContext :s ^void;
g_glContext :s ^void;

Main :: (args : [] String) -> s64
{
	g_windowHandle, g_deviceContext, g_glContext =
		GLHInitOpenGLContext(#cstr "Hello OpenGL 3.3!", #cstr "openglexample", 800, 600);

	vertexArrayId : GLuint = ?;
	glGenVertexArrays(1, ^vertexArrayId);
	glBindVertexArray(vertexArrayId);

	Vertex :: struct {
		x : GLfloat; y : GLfloat; z : GLfloat;
		u : GLfloat; v : GLfloat;
		r : GLfloat; g : GLfloat; b : GLfloat;
	};

	vertexBufferData : [6] Vertex = {
		{  1.0,  1.0,  0.0,   1.0, 1.0,   0.0, 1.0, 1.0 },
		{ -1.0, -1.0,  0.0,   0.0, 0.0,   1.0, 0.0, 1.0 },
		{ -1.0,  1.0,  0.0,   0.0, 1.0,   1.0, 1.0, 0.0 },
		{  1.0,  1.0,  0.0,   1.0, 1.0,   0.0, 1.0, 1.0 },
		{  1.0, -1.0,  0.0,   1.0, 0.0,   0.0, 1.0, 1.0 },
		{ -1.0, -1.0,  0.0,   0.0, 0.0,   1.0, 0.0, 1.0 }
	};

	// Projection matrix
	projectionMatrix : mat4 = ?;
	{
		near : f32 = 0.01;
		far : f32 = 2000.0;
		projectionMatrix = {
			0.5625, 0.0, 0.0, 0.0,
			0.0, 1.0, 0.0, 0.0,
			0.0, 0.0, -(far + near) / (far - near), -1.0,
			0.0, 0.0, -(2.0 * far * near) / (far - near), 0.0
		};
	}

	// View matrix
	viewMatrix : mat4 = ?;
	{
		pos : v3 = { 2, 1, 3 };
		camFw := V3Normalize(V3Negate(pos));
		z : v3 = { 0, 0, 1 };
		right : v3 = V3Normalize(V3Cross(camFw, z));
		up : v3 = V3Cross(right, camFw);
		invViewMatrix : mat4 = {
			right.x,	right.y,	right.z,	0.0,
			up.x,		up.y,		up.z,		0.0,
			-camFw.x,	-camFw.y,	-camFw.z,	0.0,
			pos.x,		pos.y,		pos.z,		1.0
		};

		viewMatrix = Mat4Inverse(invViewMatrix);
	}

	viewProjectionMatrix := Mat4Multiply(viewMatrix, projectionMatrix);

	vertexBuffer : GLuint = ?;
	glGenBuffers(1, ^vertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
	glBufferData(GL_ARRAY_BUFFER, cast(s64)sizeof(vertexBufferData), ^vertexBufferData, GL_STATIC_DRAW);

	vertexShaderId, fragmentShaderId : GLuint = ?;
	errorCode : GLHError = ?;
	errorCode, vertexShaderId   = GLHLoadShader("examples/opengl3example_vertexshader.glsl",   GL_VERTEX_SHADER);
	if errorCode != GLHERROR_OK return 1;
	errorCode, fragmentShaderId = GLHLoadShader("examples/opengl3example_fragmentshader.glsl", GL_FRAGMENT_SHADER);
	if errorCode != GLHERROR_OK return 1;
	programId := glCreateProgram();
	glAttachShader(programId, vertexShaderId);
	glAttachShader(programId, fragmentShaderId);
	glLinkProgram(programId);

	logSize : s32 = ?;
	glGetProgramiv(programId, GL_INFO_LOG_LENGTH, ^logSize);
	if logSize > 0 {
		programLog : String;
		programLog.size = cast(u64)logSize;
		programLog.data = cast(^u8)VirtualAlloc(0, programLog.size, MEM_COMMIT, PAGE_READWRITE);
		defer VirtualFree(programLog.data, 0, MEM_RELEASE);
		glGetProgramInfoLog(programId, logSize, null, cast(^GLchar)programLog.data);
		PrintF("%\n", programLog);
	}

	glUseProgram(programId);

	mvpUniform := glGetUniformLocation(programId, #cstr "mvpMatrix");

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	// Read texture
	textureId : GLuint;
	errorCode, textureId = GLHLoadTexture("examples/texture.bmp");
	if errorCode != GLHERROR_OK return 1;

	lastPerformanceCounter : s64;
	performanceFrequency : s64;
	{
		largeInteger : LARGE_INTEGER;
		QueryPerformanceCounter(^largeInteger);
		lastPerformanceCounter = largeInteger.QuadPart;
		QueryPerformanceFrequency(^largeInteger);
		performanceFrequency = largeInteger.QuadPart;
	}

	deltaTime : f32;

	angle : f32 = 0;

	message : MSG = ?;
	while g_running {
		// Timer
		{
			largeInteger : LARGE_INTEGER;
			QueryPerformanceCounter(^largeInteger);
			newPerfCounter := largeInteger.QuadPart;
			deltaTime = cast(f32)(newPerfCounter - lastPerformanceCounter) /
				cast(f32)performanceFrequency;
			lastPerformanceCounter = newPerfCounter;
		}

		angle += deltaTime;
		if (angle > PI2)
			angle -= PI2;
		angleSin : f32 = Sin(angle);
		angleCos : f32 = Cos(angle);
		modelMatrix : mat4 = MAT4_IDENTITY;
		modelMatrix.m00 =  angleSin;		modelMatrix.m01 = angleCos;
		modelMatrix.m10 = -angleCos;		modelMatrix.m11 = angleSin;

		mvpMatrix := Mat4Multiply(modelMatrix, viewProjectionMatrix);
		glUniformMatrix4fv(mvpUniform, 1, false, ^mvpMatrix.m00);

		glClearColor(0.8, 0.6, 0.0, 0.0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		glEnableVertexAttribArray(0);
		glEnableVertexAttribArray(1);
		glEnableVertexAttribArray(2);

		glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
		stride := cast(s32) sizeof(Vertex);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, 0);
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, 12);
		glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, stride, 20);
		glDrawArrays(GL_TRIANGLES, 0, 6);

		glDisableVertexAttribArray(0);
		glDisableVertexAttribArray(1);
		glDisableVertexAttribArray(2);

		SwapBuffers(g_deviceContext);

		while PeekMessageA(^message, 0, 0, 0, PM_REMOVE) {
			if message.message == WM_QUIT {
				g_running = 0;
			}
			else {
				TranslateMessage(^message);
				DispatchMessageA(^message);
			}
		}
	}

	return 0;
}
